#!/usr/bin/env python

from __future__ import print_function

# Label By Barcode (c) Austin G. Davis-Richardson, MIT v3
#
# Given multiplexed HiSeq raw output in FASTQ format and a list of barcodes,
# label the sequences by barcode discarding sequences that did not have a
# barcode contained in the list.

#
#
#

from Bio import SeqIO

import sys
import gzip
import string
import os
import argparse
import logging

from itertools import izip
from collections import defaultdict


class OutputHandler:
    ''' handles output
        - split by barcode (slow)
        - all one file (fast)
        - split into chunks (also fast)
        - hdf5 (wow much fast. very random sample)
    '''

    def __init__(self):
        pass

    def __enter__(self):
        pass

    def add(self, barcode, record):
        ''' append sequence '''
        pass

    def __exit__(self):
        pass


def parse_args():
    ''' parses the arguments!
        >>> args = parse_args()
    '''

    parser = argparse.ArgumentParser()
    parser.add_argument('--barcode-list', help='barcodes file')
    parser.add_argument('--seq-left', help='left seqs fastq file')
    parser.add_argument('--seq-barcode', help='barcode seqs fastq file')
    parser.add_argument('--seq-right', help='right seqs fastq file')
    parser.add_argument('--counts-table', help='reads per barcode count table', default=None)
    parser.add_argument('--output', help='either a fastq file or a directory if --split=n is enabled', default=sys.stdout)
    parser.add_argument('--revcomp-barcodes', help='reverse complement barcodes', default=False, action='store_true')
    parser.add_argument('--split', help='split output into chunks of size N. Will be saved in directory named --output', default=False, type=int)
    parser.add_argument('--split-cmd', help='runs command every time split is closed with filename as $SPLIT_PATH')
    parser.add_argument('--log', default='/dev/stderr')

    args = parser.parse_args()

    # check usage
    if not args.barcode_list or \
       not args.seq_left or \
       not args.seq_right or \
       not args.seq_barcode:
           parser.print_usage()
           quit(-1)

    return args


def load_barcodes(barcodes_file, revcomp=True):
    ''' Loads barcodes file into dictionary where
        'barcode_sequence': 'sample_id', ...

        File looks like:
        name,barcode_sequence
        ...
        name,barcode_sequence

        >>> barcodes = load_barcodes('barcodes.csv', revcomp=True)
    '''

    REVCOMP = string.maketrans('GATCNgatcn', 'CTAGNctagn')

    barcodes = {}

    logging.info('loading barcodes from %s with revcomp=%s' % (barcodes_file, revcomp))

    with open(barcodes_file) as handle:
        for line in handle:
            line = line.strip().split(',')
            name, bc = line[0], line[1]
            if revcomp:
                bc = bc[::-1].translate(REVCOMP)
            barcodes[bc] = name

    logging.info('loaded %s barcodes' % len(barcodes))

    return barcodes


def setup_input_stream(seq_left, seq_barcode, seq_right, compression=None):

    # get handles for input fastq files
    if compression == 'gzip':
        open_file = gzip.GzipFile
        logging.info('using Gzip for Input')
    elif compression == None:
        open_file = open

    left_handle = open_file(seq_left)
    barcode_handle = open_file(seq_barcode)
    right_handle = open_file(seq_right)

    left_records = SeqIO.parse(left_handle, 'fastq')
    barcode_records = SeqIO.parse(barcode_handle, 'fastq')
    right_records = SeqIO.parse(right_handle, 'fastq')

    return izip(left_records, barcode_records, right_records)


def main():
    ''' guts '''

    args = parse_args()

    logging.basicConfig(filename=args.log, level=logging.INFO)

    barcodes = load_barcodes(args.barcode_list, revcomp=args.revcomp_barcodes)

    #
    # setup output
    # - could be a file: if so, make a hanle
    # - could be a directory: if so, make the directory if it doesn't already exist
    #   and warn if it does.
    #
    if not args.split:
        out = open(args.output, 'w')
        logging.info('writing records to single file %s' % out.name)
    else:
        logging.info('storing files to directory %s in chunks of size %s' % (args.out, args.split))
        if os.path.exists(args.out):
            logging.info('warning! directory %s already exists' % args.out)
        else:
            os.mkdirs(args.out)

    # get input stream.
    input_stream = setup_input_stream(args.seq_left,
                                      args.seq_barcode,
                                      args.seq_right,
                                      compression='gzip')

    # for storing counts per barcode
    # (sort of a quality control step)
    counts = defaultdict(int)

    total_size = float(os.path.getsize(args.seq_barcode))

    matched_seqs, total_seqs, unmatched_seqs = 0, 0, 0
    index = 0

    # big, ugly main loop
    for l, b, r in input_stream:

        barcode = str(b.seq[:7]) # (adavisr) hack because barcodes were longer than expected
        name = barcodes.get(barcode, False)

        logging.debug('(barcode=%s) matched %s' % (index, name))

        total_seqs += 2

        if name == False:
            unmatched_seqs += 2
        else:
            # lame ass progress bar.
            if matched_seqs%10000 == 0:
                logging.info('matched %s barcodes from %s seqs (%.2f %%)' % \
                        (matched_seqs, total_seqs, 100*matched_seqs/float(total_seqs)))

            counts[barcode] += 2 # count both reads in pair
            matched_seqs += 2

            # QIIME-formatted header
            new_id_l = '%s %s orig_bc=%s new_bc=%s bc_diffs=0' \
                    % (name, index, barcode, barcode)
            new_id_r = '%s %s orig_bc=%s new_bc=%s bc_diffs=0' \
                    % (name, index + 1, barcode, barcode)

            l.description, r.description = '', ''
            l.id, r.id = new_id_l, new_id_r

            # write out both the left and right record!!!!
            out.write(l.format('fastq'))

            # do NOT reverse-complement the right record!!!!!!
            # (until after trimming).
            out.write(r.format('fastq'))

        if not (total_seqs == matched_seqs + unmatched_seqs):
            logging.info('total seqs does NOT equal matched + unmatched!')


    # print barcode count table.
    if args.counts_table:
        with open(args.counts_table, 'w') as handle:
            for k in counts:
                print('%s,%s' % (k, counts[k]), file=handle)

    out.close()

    # close input streams
    [ i.close() for i in input_stream ]

if __name__ == '__main__':
    main()

#!/usr/bin/env python

import argparse
import logging
from collections import defaultdict


def parse_args():

    parser = argparse.ArgumentParser()

    parser.add_argument('--inputs', required=True, nargs='*')
    parser.add_argument('--output', default='/dev/stdout')
    parser.add_argument('--qiime', action='store_true', default=True)

    return parser.parse_args()


def parse_table(handle):

    table = defaultdict(defaultdict)

    process = lambda x: x.strip().split(',')

    otus = process(handle.next())

    for line in handle:
        line = process(line)

        sample_id = line[0]
        counts = [ int(i) for i in line[1:-1] ]

        for otu_id, count in zip(otus, counts):
            table[sample_id][otu_id] = count

    return table


def save_clusters_qiime(cluster_counts, output):
    # rows are OTUs.
    # columns are samples.
    all_otus = []
    [ all_otus.extend(i.keys()) for i in cluster_counts.values() ]
    all_outs = sorted(all_otus)
    all_samples = sorted(cluster_counts.keys())

    output.write('# QIIME-formatted OTU Table\n')
    output.write('# OTU_ID\t')

    output.write('\t'.join(all_samples))
    output.write('\n')
    for cluster in all_otus:
        output.write('%s\t' % cluster)
        output.write('\t'.join( str(cluster_counts[sample].get(cluster, 0)) for sample in all_samples ))
        output.write('\n')


def write_table(table, h):
    return save_clusters_qiime(table, h)


def main():

    logging.basicConfig(level=logging.INFO, filename='/dev/stderr')

    args = parse_args()

    table = {}

    logging.info('reading from %s files' % len(args.inputs))

    for input_file in args.inputs:
        logging.info('reading %s' % input_file)
        with open(input_file) as handle:
            table.update(parse_table(handle))

    with open(args.output, 'w') as handle:
        write_table(table, handle)


if __name__ == '__main__':
    main()
